exports.createLike = (req, res, next) => {
 const userId = req.body.userId;
 const postId = req.body.postId;
 const newLike = req.body;

 db.Like.findOne({
   where: {
     userId: userId,
     postId: postId,
   },
 }).then((like) => {
   if (like) {
     db.Like.update({
       where: {
         userId: userId,
         postId: postId,
       },
     })
       .then(console.log("J'aime retirer"))
       .catch((error) => {
         res.status(400).json({ error });
       });
   } else {
     db.Like.create(newLike)
       .then(() => {
         res.status(201).json({ message: "Le like a bien été retirer" });
       })
       .catch((error) => {
         res.status(400).json({ error });
       });
   }
 }).catch();
};


item.Likes[0] &&
item.Likes[0].userId === currentUserDecoded.userId
  ? () => setPostLiked(item.id)
  : () => setPostUnLiked(item.id)




  Executing (default): SHOW INDEX FROM `Users` FROM `groupomania`
Executing (default): CREATE TABLE IF NOT EXISTS `Posts` (`postContent` VARCHAR(255), `id` INTEGER auto_increment , `userId` INTEGER, `attachment` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB;
Executing (default): SHOW INDEX FROM `Posts` FROM `groupomania`
Executing (default): CREATE TABLE IF NOT EXISTS `Comments` (`content` VARCHAR(255), `id` INTEGER auto_increment , `userId` INTEGER, `postId` INTEGER, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY 
(`userId`) REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (`postId`) REFERENCES `Posts` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB;
Executing (default): SHOW INDEX FROM `Comments` FROM `groupomania`
Executing (default): CREATE TABLE IF NOT EXISTS `Likes` (`id` INTEGER auto_increment , `userId` INTEGER, `postId` INTEGER, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (`postId`) REFERENCES `Posts` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB;
Executing (default): SHOW INDEX FROM `Likes` FROM `groupomania`



exports.updatePassword = (req, res, next) => {
  const id = req.params.id;
  const newPassword = req.body.newPassword;
  const currentPassword = req.body.currentPassword;

  db.User.findOne({ where: { id: id } })
    .then((user) => {
      if (!user) {
        return res.status(401).json({ error: "Utilisateur non enregistré" });
      }
      bcrypt
        //on compare le hash du password
        .compare(currentPassword, user.password)
        .then((passwordOk) => {
          console.log(passwordOk);
          if (!passwordOk) {
            return res.status(401).json({ error: "Mot de passe irrect" });
          } else {
            bcrypt
              // on hash le mot de passe
              .hash(newPassword, 10)
              .then((hash) => {
                db.User.update(
                  {
                    password: hash,
                  },
                  { where: { id: id } }
                ).then(() => {
                  res
                    .status(200)
                    .json({ message: "Mot de passe modifié avec succès" });
                });
              })
              .catch((error) => {
                res.status(400).json({ error });
              });
          }
        });
    })
    .catch((error) => {
      res.status(500).json({ error });
    });
};


(data) => console.log(data),
(newPasswordSucess.innerHTML = "Mot de passe modifié avec succés !"),
(inputCurrentPassword.value = ""),
(inputNewPassword.value = "")